import type { Request, Response } from "express";
import { db } from "../db";
import { admissionsTable, feeStructuresTable, parentsTable, rolesTable, studentEnrollmentTable, studentFeeAssignmentsTable, studentsTable, userRoleTable, usersTable } from "../models";
import { and, eq } from "drizzle-orm";
import bcrypt from 'bcrypt'
import type { TokenUser } from "../interface";
import { sendFirstTimeCredentialsEmail } from "../helpers/firstTimeLoginEmail";

const createAddmission = async (req: Request, res: Response) => {
    try {
        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);
        const { academicYearId, admissionDate, name, board, parentPhoneNo, applicationStatus, classId } = req.body;

        if (!academicYearId || !admissionDate || !instituteId || !name || !board || !parentPhoneNo || !classId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [existinAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.name, name),
                    eq(admissionsTable.academicYearId, academicYearId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.classId, classId)
                )
            ).limit(1);

        if (existinAddmission) {
            return res.status(400).json({ message: 'Addmission with the same name already exists for this class and academic year.', status: 400 });
        }

        const [newAddmission] = await db
            .insert(admissionsTable)
            .values({
                academicYearId,
                admissionDate,
                instituteId,
                name,
                board,
                parentPhoneNo,
                applicationStatus,
                classId
            }).returning();

        if (!newAddmission) {
            return res.status(400).json({ message: 'Failed to create the addmission', status: 400 });
        }

        return res.status(201).json({ message: 'Addmission Created Successfully', data: newAddmission, status: 201 });

    } catch (error) {
        console.log("Error creating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error creating addmission",
            status: 500,
        });
    }
}

const approveAddmission = async (req: Request, res: Response) => {
    try {
        const addmissionId = Number(req.params.id);
        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);
        const { firstName, lastName, email, phone, gender, DOB, fatherName, motherName, address } = req.body;
        const roleName = "STUDENT";

        if (!firstName || !lastName || !instituteId || !email || !phone || !gender || !DOB || !fatherName || !motherName || !address) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        if (phone.trim().length > 10) {
            return res.status(400).json({ message: "You entered more than 10 digits for the phone number", status: 400 })
        }

        const [exstingUser] = await db
            .select()
            .from(usersTable)
            .where(eq(usersTable.email, email))
            .limit(1);

        if (exstingUser) {
            return res.status(400).json({ message: 'This email is already in use', status: 400 });
        }

        if (!addmissionId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [alreadyApprovedAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.applicationStatus, 'APPROVED')
                )
            ).limit(1);

        if (alreadyApprovedAddmission) {
            return res.status(400).json({ message: "Addmission is already approved", status: 400 });
        }

        // Check if role exists in database roles table
        const [targetRole] = await db
            .select({ id: rolesTable.id, name: rolesTable.name })
            .from(rolesTable)
            .where(eq(rolesTable.name, roleName))
            .limit(1);

        if (!targetRole) {
            return res
                .status(404)
                .json({
                    status: 404,
                    message: `Role '${roleName}' not found in the database.`,
                });
        }

        // After sucessful approval of addmission create user account for student and send credentials to parent phone number or email.
        const autoGeneratedPassword = `${firstName}@${Math.floor(1000 + Math.random() * 9000)}`;

        const password_hash = bcrypt.hashSync(autoGeneratedPassword, Number(process.env.SALT_ROUNDS)).toString();

        const [newUser] = await db
            .insert(usersTable)
            .values({
                firstName,
                lastName,
                instituteId,
                email,
                phone,
                gender,
                password_hash,
                isActive: false
            }).returning();

        if (!newUser) {
            return res
                .status(500)
                .json({ message: "Failed to create user", status: 500 });
        }

        const assignedBy = (req.user && typeof req.user !== "string" && "id" in req.user) ? (req.user as TokenUser).id : undefined;

        const [userRoleAssignment] = await db.insert(userRoleTable).values({
            userId: newUser.id,         // The user we just created
            roleId: targetRole.id,      // The role they should have (STUDENT)
            assignedBy: assignedBy,     // The admin who is assigning this role
        }).returning();

        if (!userRoleAssignment) {
            // Rollback: Delete the user if role assignment fails
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res
                .status(500)
                .json({ status: 500, message: "Failed to assign role to user" });
        } else {
            await db
                .update(admissionsTable)
                .set({ userId: newUser.id })
                .where(eq(admissionsTable.id, addmissionId)).returning();
        }

        const [approveAddmission] = await db
            .update(admissionsTable)
            .set({
                applicationStatus: 'APPROVED'
            })
            .where(
                eq(admissionsTable.id, addmissionId)
            ).returning();

        if (!approveAddmission) {
            return res.status(400).json({ message: 'Failed to approve the addmission', status: 400 });
        }


        // Now the user is created and role is assigned as student successfully, so now add the entry in students table

        const [newStudentRecord] = await db
            .insert(studentsTable)
            .values({
                instituteId,
                admissionNo: addmissionId,
                userId: newUser.id,
                firstName,
                lastName,
                DOB,
                gender,
                currentClassId: approveAddmission.classId,
                status: 'ACTIVE'
            }).returning();

        if (!newStudentRecord) {
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res.status(400).json({ message: 'Failed to create an entry in the studentTable', status: 400 })
        }

        // Assign Fees
        // Fetch all COMPULSORY fee structures for this class and academic year
        const feeStructures = await db
            .select()
            .from(feeStructuresTable)
            .where(
                and(
                    eq(feeStructuresTable.classId, approveAddmission.classId),
                    eq(feeStructuresTable.academicYearId, approveAddmission.academicYearId),
                    eq(feeStructuresTable.instituteId, instituteId),
                    eq(feeStructuresTable.isCompulsory, true)
                )
            );

        if (feeStructures.length === 0) {
            return res.status(404).json({
                message: "No compulsory fee structures found for this class",
                status: 404
            });
        }

        const alreadyAssigned = await db
            .select()
            .from(studentFeeAssignmentsTable)
            .where(
                and(
                    eq(studentFeeAssignmentsTable.studentId, newStudentRecord.id),
                    eq(studentFeeAssignmentsTable.instituteId, instituteId),
                )
            ).limit(1);

        if (alreadyAssigned.length > 0) {
            return res.status(400).json({
                message: "Fees are already assigned to this student",
                status: 400,
                existingAssignments: alreadyAssigned.length
            })
        }

        // Prepare assignments for all compulsory fees
        const assignments = feeStructures.map(feeStructure => {
            const baseAmount = parseFloat(feeStructure.amount);
            const discount = parseFloat("0");

            // Calculate effective amount
            let effectiveAmount: number;
            const isWaived = false;
            if (isWaived) {
                effectiveAmount = 0; // Fully waived
            } else {
                // Apply discount: amount - (amount * discount / 100)
                effectiveAmount = baseAmount - (baseAmount * discount / 100);
            }

            return {
                studentId: newStudentRecord.id,
                instituteId,
                feeStructureId: feeStructure.id,
                customAmount: null, // Can be set for individual fee heads if needed
                discountPercentage: null,
                discountReason: 'none',
                isWaived,
                waivedReason: 'none',
                effectiveAmount: effectiveAmount.toFixed(2),
                assignedBy
            };
        });

        // Insert all fee assignments in one transaction
        const assignedFees = await db
            .insert(studentFeeAssignmentsTable)
            .values(assignments)
            .returning();

        if (!assignedFees || assignedFees.length === 0) {
            return res.status(400).json({
                message: "Failed to assign fees to the student",
                status: 400
            });
        }

        // As we get the fees now add the parents details entry in the parentsTable
        const [checkIfParentExists] = await db
            .select()
            .from(parentsTable)
            .where(
                and(
                    eq(parentsTable.studentId, newStudentRecord.id),
                    eq(parentsTable.fatherName, fatherName)
                )
            ).limit(1);

        if (checkIfParentExists) {
            return res.status(400).json({ message: "Parent already exist for this student", status: 400 });
        }

        const [parentsRecord] = await db
            .insert(parentsTable)
            .values({
                studentId: newStudentRecord?.id,
                instituteId,
                fatherName,
                motherName,
                primaryPhone: phone,
                address
            }).returning();

        if (!parentsRecord) {
            // ROLLBACK: Delete student and user
            await db.delete(studentsTable).where(eq(studentsTable.id, newStudentRecord.id));
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res.status(400).json({ message: "Failed to create parent record. Admission not approved.", status: 400 });
        }

        const [studentEnrollmentEntry] = await db
            .insert(studentEnrollmentTable)
            .values({
                studentId: newStudentRecord.id,
                classId: approveAddmission.classId,
                sectionId: null,
                academicYearId: approveAddmission.academicYearId,
                enrollmentDate: String(Date.now()),
                status: 'ACTIVE',
            }).returning({
                id: studentEnrollmentTable.id,
                studentId: studentEnrollmentTable.studentId,
                status: studentEnrollmentTable.status,
            });

        if (!studentEnrollmentEntry?.id) {
            return res.status(400).json({
                message: "Failed to create the studentEnrollment entry",
                status: 400
            })
        }

        // Admission → Approval → User Creation → Enrollment → Assign Fees → ParentTableEntry → StudentEnrollmentTableEntry -> Login Access
        const sendCredentialsOnMail = await sendFirstTimeCredentialsEmail(
            {
                parentEmail: email,
                studentName: firstName,
                temporaryPassword: autoGeneratedPassword,
                instituteId: instituteId
            }
        );

        if (!sendCredentialsOnMail.success) {
            console.warn("Email sending failed but admission approved:", sendCredentialsOnMail.message);
            return res.status(200).json({
                "status": "APPROVED",
                "message": "Admission approved successfully",
                "emailStatus": "FAILED",
                "warning": "Email notification could not be sent. You may resend it later."
            })
        }

        return res.status(200).json({
            success: true,
            message: "Admission approved ,user created,fees assigned and credentials sent to parent email",
            data: newUser
        });

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error approving addmission",
            status: 500,
        });
    }
}

// update the addmission status
const updateAddmissionStatus = async (req: Request, res: Response) => {
    try {
        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);
        const { status, addmissionId } = req.body;

        if (!status || !addmissionId || !instituteId) {
            return res.status(400).json({
                message: "Please provide required fields",
                status: 400
            })
        }

        const [addmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.isDeleted, false)
                )
            ).limit(1);

        if (!addmission) {
            return res.status(404).json({
                message: "Addmission with the admissionId not found in this institute",
                status: 404
            })
        }

        const [updateAddmissionStatus] = await db
            .update(admissionsTable)
            .set({
                applicationStatus: status
            }).returning({
                admissionId: admissionsTable.id,
                instituteId: admissionsTable.instituteId,
                status: admissionsTable.applicationStatus
            });

        if (!updateAddmissionStatus) {
            return res.status(400).json({
                message: "failed to update the addmission application status",
                status: 400
            })
        }

        return res.json(200).json({
            message: "Admission status updated successfully",
            status: 200,
            data: updateAddmissionStatus
        })

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error updating addmission",
            status: 500,
        });
    }
}

// Delete only the admissions that are PENDING/REJECTED/INQUIRY
const deleteAddmission = async (req: Request, res: Response) => {
    try {
        const addmissionId = Number(req.params.addmissionId);
        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);

        if (!addmissionId || !instituteId) {
            return res.status(400).json({
                message: "Please provide valid fields",
                status: 400
            })
        }

        const [addmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.isDeleted, false)
                )
            ).limit(1);

        if (!addmission) {
            return res.status(404).json({
                message: "Addmission not found",
                status: 404
            })
        }

        const status = addmission.applicationStatus;

        if (status === "APPROVED") {
            return res.status(400).json({
                message: "This admission is already approved can't delete this. Unenroll the admission first",
                status: 400
            })
        }

        const [deleteAddmission] = await db
            .delete(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.instituteId, instituteId)
                )
            ).returning();

        if (!deleteAddmission) {
            return res.status(400).json({
                message: "Failed to delete the addmission",
                status: 400
            })
        }

        return res.status(200).json({
            message: `Admission entry deleted with status : ${status}`,
            status: 200
        })


    } catch (error) {
        console.log("Error deleting addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error deleting addmission",
            status: 500,
        });
    }
}

const softDeleteAddmission = async (req: Request, res: Response) => {
    try {
        const admissionId = Number(req.params.admissionId);
        const { instituteId, id: userId } = req.user as TokenUser;
        const { reason } = req.body || "none";
        const numInstituteId = Number(instituteId);

        if (!admissionId || !numInstituteId || isNaN(admissionId)) {
            return res.status(400).json({
                message: "Valid admission ID is required",
                status: 400
            })
        }

        // Check if admission exists and not already deleted
        const [admission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, admissionId),
                    eq(admissionsTable.instituteId, numInstituteId),
                    eq(admissionsTable.isDeleted, false)
                )
            )
            .limit(1);

        if (!admission) {
            return res.status(404).json({
                success: false,
                message: "Admission not found or already deleted"
            });
        }

        // Check if approved and has enrolled student
        if (admission.applicationStatus === 'APPROVED' && admission.userId) {
            const [student] = await db
                .select({ currentSectionId: studentsTable.currentSectionId })
                .from(studentsTable)
                .where(eq(studentsTable.userId, admission.userId))
                .limit(1);

            if (student?.currentSectionId) {
                return res.status(400).json({
                    success: false,
                    message: "Cannot delete. Student is enrolled. Please unenroll first."
                });
            }
        }

        // Soft delete - just mark as deleted
        const [deletedAdmission] = await db
            .update(admissionsTable)
            .set({
                isDeleted: true,
                deletedAt: new Date(),
                deletedBy: userId,
                deletionReason: reason || 'No reason provided'
            })
            .where(eq(admissionsTable.id, admissionId))
            .returning();

        // Also deactivate user if exists
        if (admission.userId) {
            await db
                .update(usersTable)
                .set({ isActive: false })
                .where(eq(usersTable.id, admission.userId));
        }

        return res.status(200).json({
            status: 200,
            message: "Admission soft deleted successfully",
            data: {
                admissionId: deletedAdmission?.id,
                deletedAt: deletedAdmission?.deletedAt
            }
        });


    } catch (error) {
        console.log("Error deleting addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error soft deleting addmission",
            status: 500,
        });
    }
}

const restoreAdmission = async (req: Request, res: Response) => {
    try {
        const admissionId = Number(req.params.admissionId);
        const { instituteId } = req.user as TokenUser;
        const numInstituteId = Number(instituteId);

        if (!admissionId || !instituteId) {
            return res.status(400).json({
                message: "Valid admission ID is required",
                status: 400
            })
        }

        const [admission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, admissionId),
                    eq(admissionsTable.instituteId, numInstituteId),
                    eq(admissionsTable.isDeleted, true)
                )
            )
            .limit(1);

        if (!admission) {
            return res.status(404).json({
                success: false,
                message: "Deleted admission not found"
            });
        }

        const [restored] = await db
            .update(admissionsTable)
            .set({
                isDeleted: false,
                deletedAt: null,
                deletedBy: null,
                deletionReason: null
            })
            .where(eq(admissionsTable.id, admissionId))
            .returning();

        // Reactivate user if exists
        if (admission.userId) {
            await db
                .update(usersTable)
                .set({ isActive: true })
                .where(eq(usersTable.id, admission.userId));
        }

        return res.status(200).json({
            status: 200,
            message: "Admission restored successfully",
            data: restored
        });

    } catch (error) {
        console.log("Error restoring addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error restoring addmission",
            status: 500,
        });
    }
}

// This will get all approved admissions for an institute in a particular academic year
const getAllAddmissions = async (req: Request, res: Response) => {
    try {
        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);
        const yearId = Number(req.params.yearId);

        if (!instituteId || !yearId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }
        const allAdmissions = await db
            .select()
            .from(admissionsTable)
            .where(and(
                eq(admissionsTable.instituteId, instituteId),
                eq(admissionsTable.isDeleted, false),
                eq(admissionsTable.applicationStatus, 'APPROVED'),
                eq(admissionsTable.academicYearId, yearId)
            ));

        return res.status(200).json({
            message: `All Admissions for instituteId: ${instituteId} `,
            data: allAdmissions,
            status: 200
        })


    } catch (error) {
        console.log("Error getting all addmissions: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting all addmissions",
            status: 500,
        });
    }
}

const getAddmission = async (req: Request, res: Response) => {
    try {

        const loggedInUser = req.user as TokenUser;
        const instituteId = Number(loggedInUser?.instituteId);
        const addmissionId = Number(req.params.addmissionId);

        if (!addmissionId || !instituteId) {
            return res.status(400).json({
                message: 'Please provide required fields',
                status: 400
            });
        }

        const [addmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.isDeleted, false)
                )
            ).limit(1);

        if (!addmission) {
            return res.status(400).json({
                message: "No addmission for this id",
                status: 400
            })
        }

        return res.status(200).json({
            message: "Addmission found",
            data: addmission,
            status: 200
        })

    } catch (error) {
        console.log("Error getting specific addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting specific addmission",
            status: 500,
        });
    }
}

export {
    createAddmission,
    updateAddmissionStatus,
    deleteAddmission,
    softDeleteAddmission,
    getAddmission,
    getAllAddmissions,
    approveAddmission,
    restoreAdmission
};