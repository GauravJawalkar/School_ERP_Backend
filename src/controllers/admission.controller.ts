import type { Request, Response } from "express";
import { db } from "../db";
import { admissionsTable, rolesTable, studentsTable, userRoleTable, usersTable } from "../models";
import { and, eq } from "drizzle-orm";
import bcrypt from 'bcrypt'
import type { TokenUser } from "../interface";
import { sendFirstTimeCredentialsEmail } from "../helpers/firstTimeLoginEmail";

const createAddmission = async (req: Request, res: Response) => {
    try {
        const { academicYearId, admissionDate, instituteId, name, board, parentPhoneNo, applicationStatus, classId } = req.body;

        if (!academicYearId || !admissionDate || !instituteId || !name || !board || !parentPhoneNo || !classId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [existinAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.name, name),
                    eq(admissionsTable.academicYearId, academicYearId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.classId, classId)
                )
            ).limit(1);

        if (existinAddmission) {
            return res.status(400).json({ message: 'Addmission with the same name already exists for this class and academic year.', status: 400 });
        }

        const [newAddmission] = await db
            .insert(admissionsTable)
            .values({
                academicYearId,
                admissionDate,
                instituteId,
                name,
                board,
                parentPhoneNo,
                applicationStatus,
                classId
            }).returning();

        if (!newAddmission) {
            return res.status(400).json({ message: 'Failed to create the addmission', status: 400 });
        }

        return res.status(201).json({ message: 'Addmission Created Successfully', data: newAddmission, status: 201 });

    } catch (error) {
        console.log("Error creating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error creating addmission",
            status: 500,
        });
    }
}

const approveAddmission = async (req: Request, res: Response) => {
    // TODO : For approving addmission application just check if the fee is 30% fee is paid or not.
    try {
        const addmissionId = Number(req.params.id);
        const { firstName, lastName, instituteId, email, phone, gender, DOB } = req.body;
        const roleName = "STUDENT";

        if (!firstName || !lastName || !instituteId || !email || !phone || !gender || !DOB) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [exstingUser] = await db
            .select()
            .from(usersTable)
            .where(eq(usersTable.email, email))
            .limit(1);

        if (exstingUser) {
            return res.status(400).json({ message: 'This email is already in use', status: 400 });
        }

        if (!addmissionId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [alreadyApprovedAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.applicationStatus, 'APPROVED')
                )
            ).limit(1);

        if (alreadyApprovedAddmission) {
            return res.status(400).json({ message: "Addmission is already approved", status: 400 });
        }

        const [approveAddmission] = await db
            .update(admissionsTable)
            .set({
                applicationStatus: 'APPROVED'
            })
            .where(
                eq(admissionsTable.id, addmissionId)
            ).returning();

        if (!approveAddmission) {
            return res.status(400).json({ message: 'Failed to approve the addmission', status: 400 });
        }

        // Check if role exists in database roles table
        const [targetRole] = await db
            .select({ id: rolesTable.id, name: rolesTable.name })
            .from(rolesTable)
            .where(eq(rolesTable.name, roleName))
            .limit(1);

        if (!targetRole) {
            return res
                .status(404)
                .json({
                    status: 404,
                    message: `Role '${roleName}' not found in the database.`,
                });
        }

        // After sucessful approval of addmission create user account for student and send credentials to parent phone number or email.
        const autoGeneratedPassword = `${firstName}@${Math.floor(1000 + Math.random() * 9000)}`;

        const password_hash = bcrypt.hashSync(autoGeneratedPassword, Number(process.env.SALT_ROUNDS)).toString();

        const [newUser] = await db
            .insert(usersTable)
            .values({
                firstName,
                lastName,
                instituteId,
                email,
                phone,
                gender,
                password_hash,
                isActive: false
            }).returning();

        if (!newUser) {
            return res
                .status(500)
                .json({ message: "Failed to create user", status: 500 });
        }

        const assignedBy = (req.user && typeof req.user !== "string" && "id" in req.user) ? (req.user as TokenUser).id : undefined;

        const [userRoleAssignment] = await db.insert(userRoleTable).values({
            userId: newUser.id,         // The user we just created
            roleId: targetRole.id,      // The role they should have (STUDENT)
            assignedBy: assignedBy,     // The admin who is assigning this role
        }).returning();

        if (!userRoleAssignment) {
            // Rollback: Delete the user if role assignment fails
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res
                .status(500)
                .json({ status: 500, message: "Failed to assign role to user" });
        } else {
            await db
                .update(admissionsTable)
                .set({ userId: newUser.id })
                .where(eq(admissionsTable.id, addmissionId)).returning();
        }

        // Now the user is created and role is assigned as student successfully, so now add the entry in students table

        const [newStudentRecord] = await db
            .insert(studentsTable)
            .values({
                instituteId,
                admissionNo: addmissionId,
                userId: newUser.id,
                firstName,
                lastName,
                DOB,
                gender,
                currentClassId: approveAddmission.classId,
                status: 'ACTIVE'
            }).returning();

        if (!newStudentRecord) {
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res.status(400).json({ message: 'Failed to create an entry in the studentTable', status: 400 })
        }

        // Admission → Approval → User Creation → Enrollment → Login Access

        const sendCredentialsOnMail = await sendFirstTimeCredentialsEmail(
            {
                parentEmail: email,
                studentName: firstName,
                temporaryPassword: autoGeneratedPassword,
                instituteId: instituteId
            }
        );

        if (!sendCredentialsOnMail.success) {
            console.warn("Email sending failed but admission approved:", sendCredentialsOnMail.message);
        }

        return res.status(200).json({
            success: true,
            message: "Admission approved ,user created and credentials sent to parent email",
            data: newUser
        });

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error approving addmission",
            status: 500,
        });
    }
}

const updateAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error updating addmission",
            status: 500,
        });
    }
}

const deleteAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error deleting addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error deleting addmission",
            status: 500,
        });
    }
}

const getAllAddmissions = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error getting all addmissions: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting all addmissions",
            status: 500,
        });
    }
}

const getAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error getting specific addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting specific addmission",
            status: 500,
        });
    }
}

export { createAddmission, updateAddmission, deleteAddmission, getAddmission, getAllAddmissions, approveAddmission };