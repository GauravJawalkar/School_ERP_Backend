import type { Request, Response } from "express";
import { db } from "../db";
import { admissionsTable, feeStructuresTable, parentsTable, rolesTable, studentFeeAssignmentsTable, studentsTable, userRoleTable, usersTable } from "../models";
import { and, eq } from "drizzle-orm";
import bcrypt from 'bcrypt'
import type { TokenUser } from "../interface";
import { sendFirstTimeCredentialsEmail } from "../helpers/firstTimeLoginEmail";

const createAddmission = async (req: Request, res: Response) => {
    try {
        const { academicYearId, admissionDate, instituteId, name, board, parentPhoneNo, applicationStatus, classId } = req.body;

        if (!academicYearId || !admissionDate || !instituteId || !name || !board || !parentPhoneNo || !classId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [existinAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.name, name),
                    eq(admissionsTable.academicYearId, academicYearId),
                    eq(admissionsTable.instituteId, instituteId),
                    eq(admissionsTable.classId, classId)
                )
            ).limit(1);

        if (existinAddmission) {
            return res.status(400).json({ message: 'Addmission with the same name already exists for this class and academic year.', status: 400 });
        }

        const [newAddmission] = await db
            .insert(admissionsTable)
            .values({
                academicYearId,
                admissionDate,
                instituteId,
                name,
                board,
                parentPhoneNo,
                applicationStatus,
                classId
            }).returning();

        if (!newAddmission) {
            return res.status(400).json({ message: 'Failed to create the addmission', status: 400 });
        }

        return res.status(201).json({ message: 'Addmission Created Successfully', data: newAddmission, status: 201 });

    } catch (error) {
        console.log("Error creating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error creating addmission",
            status: 500,
        });
    }
}

// When approving the addmission the parent email is used to create user account for the student. So need to add parents Details in the addmission creation so that the approved student parent will get linked in the parentsTable
const approveAddmission = async (req: Request, res: Response) => {
    try {
        const addmissionId = Number(req.params.id);
        const { firstName, lastName, instituteId, email, phone, gender, DOB, fatherName, motherName, address } = req.body;
        const roleName = "STUDENT";

        if (!firstName || !lastName || !instituteId || !email || !phone || !gender || !DOB || !fatherName || !motherName || !address) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        if (phone.trim().length > 10) {
            return res.status(400).json({ message: "You entered more than 10 digits for the phone number", status: 400 })
        }

        const [exstingUser] = await db
            .select()
            .from(usersTable)
            .where(eq(usersTable.email, email))
            .limit(1);

        if (exstingUser) {
            return res.status(400).json({ message: 'This email is already in use', status: 400 });
        }

        if (!addmissionId) {
            return res.status(400).json({ message: 'Please provide required fields', status: 400 });
        }

        const [alreadyApprovedAddmission] = await db
            .select()
            .from(admissionsTable)
            .where(
                and(
                    eq(admissionsTable.id, addmissionId),
                    eq(admissionsTable.applicationStatus, 'APPROVED')
                )
            ).limit(1);

        if (alreadyApprovedAddmission) {
            return res.status(400).json({ message: "Addmission is already approved", status: 400 });
        }

        // Check if role exists in database roles table
        const [targetRole] = await db
            .select({ id: rolesTable.id, name: rolesTable.name })
            .from(rolesTable)
            .where(eq(rolesTable.name, roleName))
            .limit(1);

        if (!targetRole) {
            return res
                .status(404)
                .json({
                    status: 404,
                    message: `Role '${roleName}' not found in the database.`,
                });
        }

        // After sucessful approval of addmission create user account for student and send credentials to parent phone number or email.
        const autoGeneratedPassword = `${firstName}@${Math.floor(1000 + Math.random() * 9000)}`;

        const password_hash = bcrypt.hashSync(autoGeneratedPassword, Number(process.env.SALT_ROUNDS)).toString();

        const [newUser] = await db
            .insert(usersTable)
            .values({
                firstName,
                lastName,
                instituteId,
                email,
                phone,
                gender,
                password_hash,
                isActive: false
            }).returning();

        if (!newUser) {
            return res
                .status(500)
                .json({ message: "Failed to create user", status: 500 });
        }

        const assignedBy = (req.user && typeof req.user !== "string" && "id" in req.user) ? (req.user as TokenUser).id : undefined;

        const [userRoleAssignment] = await db.insert(userRoleTable).values({
            userId: newUser.id,         // The user we just created
            roleId: targetRole.id,      // The role they should have (STUDENT)
            assignedBy: assignedBy,     // The admin who is assigning this role
        }).returning();

        if (!userRoleAssignment) {
            // Rollback: Delete the user if role assignment fails
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res
                .status(500)
                .json({ status: 500, message: "Failed to assign role to user" });
        } else {
            await db
                .update(admissionsTable)
                .set({ userId: newUser.id })
                .where(eq(admissionsTable.id, addmissionId)).returning();
        }

        const [approveAddmission] = await db
            .update(admissionsTable)
            .set({
                applicationStatus: 'APPROVED'
            })
            .where(
                eq(admissionsTable.id, addmissionId)
            ).returning();

        if (!approveAddmission) {
            return res.status(400).json({ message: 'Failed to approve the addmission', status: 400 });
        }


        // Now the user is created and role is assigned as student successfully, so now add the entry in students table

        const [newStudentRecord] = await db
            .insert(studentsTable)
            .values({
                instituteId,
                admissionNo: addmissionId,
                userId: newUser.id,
                firstName,
                lastName,
                DOB,
                gender,
                currentClassId: approveAddmission.classId,
                status: 'ACTIVE'
            }).returning();

        if (!newStudentRecord) {
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res.status(400).json({ message: 'Failed to create an entry in the studentTable', status: 400 })
        }

        // Assign Fees
        // Fetch all COMPULSORY fee structures for this class and academic year
        const feeStructures = await db
            .select()
            .from(feeStructuresTable)
            .where(
                and(
                    eq(feeStructuresTable.classId, approveAddmission.classId),
                    eq(feeStructuresTable.academicYearId, approveAddmission.academicYearId),
                    eq(feeStructuresTable.instituteId, instituteId),
                    eq(feeStructuresTable.isCompulsory, true)
                )
            );

        if (feeStructures.length === 0) {
            return res.status(404).json({
                message: "No compulsory fee structures found for this class",
                status: 404
            });
        }

        const alreadyAssigned = await db
            .select()
            .from(studentFeeAssignmentsTable)
            .where(
                and(
                    eq(studentFeeAssignmentsTable.studentId, newStudentRecord.id),
                    eq(studentFeeAssignmentsTable.instituteId, instituteId),
                )
            ).limit(1);

        if (alreadyAssigned.length > 0) {
            return res.status(400).json({
                message: "Fees are already assigned to this student",
                status: 400,
                existingAssignments: alreadyAssigned.length
            })
        }

        // Prepare assignments for all compulsory fees
        const assignments = feeStructures.map(feeStructure => {
            const baseAmount = parseFloat(feeStructure.amount);
            const discount = parseFloat("0");

            // Calculate effective amount
            let effectiveAmount: number;
            const isWaived = false;
            if (isWaived) {
                effectiveAmount = 0; // Fully waived
            } else {
                // Apply discount: amount - (amount * discount / 100)
                effectiveAmount = baseAmount - (baseAmount * discount / 100);
            }

            return {
                studentId: newStudentRecord.id,
                instituteId,
                feeStructureId: feeStructure.id,
                customAmount: null, // Can be set for individual fee heads if needed
                discountPercentage: null,
                discountReason: 'none',
                isWaived,
                waivedReason: 'none',
                effectiveAmount: effectiveAmount.toFixed(2),
                assignedBy
            };
        });

        // Insert all fee assignments in one transaction
        const assignedFees = await db
            .insert(studentFeeAssignmentsTable)
            .values(assignments)
            .returning();

        if (!assignedFees || assignedFees.length === 0) {
            return res.status(400).json({
                message: "Failed to assign fees to the student",
                status: 400
            });
        }

        // As we get the fees now add the parents details entry in the parentsTable
        const [checkIfParentExists] = await db
            .select()
            .from(parentsTable)
            .where(
                and(
                    eq(parentsTable.studentId, newStudentRecord.id),
                    eq(parentsTable.fatherName, fatherName)
                )
            ).limit(1);

        if (checkIfParentExists) {
            return res.status(400).json({ message: "Parent already exist for this student", status: 400 });
        }

        const [parentsRecord] = await db
            .insert(parentsTable)
            .values({
                studentId: newStudentRecord?.id,
                instituteId,
                fatherName,
                motherName,
                primaryPhone: phone,
                address
            }).returning();

        if (!parentsRecord) {
            // ROLLBACK: Delete student and user
            await db.delete(studentsTable).where(eq(studentsTable.id, newStudentRecord.id));
            await db.delete(usersTable).where(eq(usersTable.id, newUser.id));
            return res.status(400).json({ message: "Failed to create parent record. Admission not approved.", status: 400 });
        }

        // Admission → Approval → User Creation → Enrollment → Assign Fees → ParentTableEntry →Login Access
        const sendCredentialsOnMail = await sendFirstTimeCredentialsEmail(
            {
                parentEmail: email,
                studentName: firstName,
                temporaryPassword: autoGeneratedPassword,
                instituteId: instituteId
            }
        );

        if (!sendCredentialsOnMail.success) {
            console.warn("Email sending failed but admission approved:", sendCredentialsOnMail.message);
            return res.status(200).json({
                "status": "APPROVED",
                "message": "Admission approved successfully",
                "emailStatus": "FAILED",
                "warning": "Email notification could not be sent. You may resend it later."
            })
        }

        return res.status(200).json({
            success: true,
            message: "Admission approved ,user created,fees assigned and credentials sent to parent email",
            data: newUser
        });

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error approving addmission",
            status: 500,
        });
    }
}

const updateAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error updating addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error updating addmission",
            status: 500,
        });
    }
}

const deleteAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error deleting addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error deleting addmission",
            status: 500,
        });
    }
}

const getAllAddmissions = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error getting all addmissions: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting all addmissions",
            status: 500,
        });
    }
}

const getAddmission = async (req: Request, res: Response) => {
    try {

    } catch (error) {
        console.log("Error getting specific addmission: ", error);
        return res.status(500).json({
            message: "Internal Server Error getting specific addmission",
            status: 500,
        });
    }
}

export { createAddmission, updateAddmission, deleteAddmission, getAddmission, getAllAddmissions, approveAddmission };